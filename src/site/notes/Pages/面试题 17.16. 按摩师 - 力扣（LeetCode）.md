---
{"aliases":"按摩师","created":"2023-01-14 23:20:46","updated":"2023-01-14 23:31:13","tags":["leetcode","动态规划","easy"],"source":"https://leetcode.cn/problems/the-masseuse-lcci/","title":"面试题 17.16. 按摩师 - 力扣（LeetCode）","dg-publish":true,"permalink":"/Pages/面试题 17.16. 按摩师 - 力扣（LeetCode）/","dgPassFrontmatter":true}
---


# 面试题 17.16. 按摩师 - 力扣（LeetCode）

[面试题 17.16. 按摩师 - 力扣（LeetCode）](https://leetcode.cn/problems/the-masseuse-lcci/)

---

一个有名的按摩师会收到源源不断的预约请求，每个预约都可以选择接或不接。在每次预约服务之间要有休息时间，因此她不能接受相邻的预约。给定一个预约请求序列，替按摩师找到最优的预约集合（总预约时间最长），返回总的分钟数。

**注意：** 本题相对原题稍作改动

**示例 1：**

```
输入： [1,2,3,1]
输出： 4
解释： 选择 1 号预约和 3 号预约，总时长 = 1 + 3 = 4。

```

**示例 2：**

```
输入： [2,7,9,3,1]
输出： 12
解释： 选择 1 号预约、 3 号预约和 5 号预约，总时长 = 2 + 9 + 1 = 12。

```

**示例 3：**

```
输入： [2,1,4,5,3,1,1,3]
输出： 12
解释： 选择 1 号预约、 3 号预约、 5 号预约和 8 号预约，总时长 = 2 + 4 + 3 + 3 = 12。

```

---

- easy
- [[Pages/877. 石子游戏 - 力扣（LeetCode）\|877. 石子游戏 - 力扣（LeetCode）]]
- [[Pages/801. 使序列递增的最小交换次数 - 力扣（LeetCode）\|801. 使序列递增的最小交换次数 - 力扣（LeetCode）]]

```cpp

class Solution {
public:
    int massage(vector<int>& nums) {
        int n =nums.size();
        if(n==0) return 0;
        if(n==1) return nums[0];
        vector<vector<int>> dp(n, vector<int>(2, 0));
        dp[0][0] = 0;
        dp[0][1] = nums[0];
        for(int i=1; i<n; i++){
            dp[i][0] = max(dp[i-1][0], dp[i-1][1]);
            dp[i][1] = dp[i-1][0]+nums[i];
        }
        return max(dp[n-1][0], dp[n-1][1]);
    }
};
```

---
> I am always ready to learn although I do not always like being taught.  
> — <cite>Winston Churchill</cite>
