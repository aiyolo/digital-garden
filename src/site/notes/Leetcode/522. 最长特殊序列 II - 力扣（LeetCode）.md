---
{"dg-publish":true,"permalink":"/leetcode/522-ii-leet-code/","title":"522. 最长特殊序列 II - 力扣（LeetCode）","tags":["leetcode","子序列"]}
---


# 522. 最长特殊序列 II - 力扣（LeetCode）

[522. 最长特殊序列 II - 力扣（LeetCode）](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)

---

给定字符串列表 `strs` ，返回其中 **最长的特殊序列** 。如果最长特殊序列不存在，返回 `-1` 。

**特殊序列** 定义如下：该序列为某字符串 **独有的子序列（即不能是其他字符串的子序列）**。

 `s` 的 **子序列** 可以通过删去字符串 `s` 中的某些字符实现。

- 例如，`"abc"` 是 `"aebdc"` 的子序列，因为您可以删除 `"aebdc"` 中的下划线字符来得到 `"abc"` 。`"aebdc"` 的子序列还包括 `"aebdc"`、 `"aeb"` 和 "" (空字符串)。

**示例 1：**

```
输入: strs = ["aba","cdc","eae"]
输出: 3

```

**示例 2:**

```
输入: strs = ["aaa","aaa","aa"]
输出: -1

```

**提示:**

- `2 <= strs.length <= 50`
- `1 <= strs[i].length <= 10`
- `strs[i]` 只包含小写英文字母

---

### 解题思路

- 判断字符串 s 是否是字符串 t 的子序列，只要在 t 中能找到 s 的所有字符即可
- 遍历字符串，找到一个不是其他所有字符串子序列的字符

 #子序列

```cpp
// 2023-03-09 11:02
class Solution {
public:
	//判断字符串s是否为t的子序列
    bool issub(string& s, string& t){
        int i=0, j=0;
        while(i<s.size() && j<t.size()){
            if(s[i]==t[j]){
                i++;
            }
            j++;
        }
        return i==s.size();
    }
    int findLUSlength(vector<string>& strs) {
        int n = strs.size();
        int ans = -1;
        for(int i=0; i<n; i++){
            bool isSpecial = true;
            for(int j=0; j<n; j++){
                if(i!=j && issub(strs[i], strs[j])){ // i!=j必须放在if里，不能放在for
                    isSpecial = false;
                    break;
                }
            }
            if(isSpecial) ans = max(ans, static_cast<int>(strs[i].size()));
        }
        return ans;
    }
};
```

### 相关题目

```dataview
Table source as URL
WHERE contains(file.name, "序列")
SORT file.ctime desc
```

### 历史记录

```cpp
class Solution {
public:
	//判断字符串s是否为t的子序列
    bool isSub(const string& s, const string& t){
        int ps=0, pt=0;
        while(ps<s.size() && pt<t.size()){
            if(s[ps]==t[pt]){
                ps++;
            }
            pt++;
        }
        return ps==s.size();
    }
    int findLUSlength(vector<string>& strs) {
        int ans=-1;
        for(int i=0; i<strs.size(); i++){
            bool flag=true;
            for(int j=0; j<strs.size(); j++){
                if(i!=j && isSub(strs[i], strs[j])){
                    flag = false;
                    break;
                }
            }
            if(flag) ans = max(ans, static_cast<int>(strs[i].size())); //cast
        }
        return ans;
    }
};

```

---

> Chaos is inherent in all compounded things. Strive on with diligence.  
> — <cite>Buddha</cite>
